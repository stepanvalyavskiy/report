\documentclass[acmlarge, screen, nonacm]{acmart}
\usepackage[utf8]{inputenc}
\usepackage{float}
\usepackage{setspace}
\usepackage{pgfplots}
\usepackage{graphicx}
\usepackage{fancyvrb}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
  \hypersetup{colorlinks=true,allcolors=blue!40!black}
\setlength{\topskip}{6pt}
\setlength{\parindent}{0pt} % indent first line
\setlength{\parskip}{6pt} % before par

\title{Implementation of consensus algorithms on git side}

\author{Stepan Valiavskii}
\email{stepan.valiavskii@huawei.com}

\begin{document}

\begin{abstract}
To achieve strong consistency in DeGitX we need to solve a problem of atomic commit over N git servers.
It isn't always possible to undo changes in git, so we need to manage git transactions and provide abortion mechanism as well.
Fortunately, we aren't the first who met the problem of atomic commit.
There are several well known algorithms as: 2PC, 3PC and Paxos-Commit.
Theoretically, each of them could solve our problem.
We have investigated how they could be implemented with git.
We stay on 2PC integrated in git reference transaction hook.
The problem is particularly solved.
Now we need to implement it and do benchmarking.
\end{abstract}

\maketitle

\section{Problem}

DeGitX keep three copies of every repository on three different servers.
We need to keep repositories fully
available without interruption even if one of those servers goes down.
Even in the extreme case that two copies of a repository become unavailable at
the same time, the repository should remains readable, i.e., fetches, clones, and
most of the web UI continue to work.
We need to implement replication at the application layer, rather than at the disk layer.
When the replicas are three loosely-coupled Git repositories kept
in sync via Git protocols, rather than identical disk images full of repositories,
it gives us great flexibility to decide where to
store the replicas of a repository and which replica to use for read operations.

To split read traffic over replicas and to remain repository readable even if two copies become unavailable,
we need to ensure that every Git update is safely replicated to all of the replicas in most cases
and to at least a quorum of replicas in every case.

So what should be done to do an atomic commit in 3 git replicas:
\begin{enumerate}
  \item on each node: lock all data that going to be changed (this sync section should be extremely small).
  \item on each node: verify if commit could be accepted.
  \item do voting and notify all nodes about decision: accept or discard.
  \item accept/discard changes on all nodes or at least on quorum.
  \item release locks.
  \item schedule replication for outdated node, if changes were accepted by quorum (2/3 nodes) and mark node as outdated (Such node stops accepts read requests till restoring).
  \item replicate outdated node.
\end{enumerate}

\section{Related works}

GitHub Spokes - not open sourced.

Spokes uses the three-phase commit protocol to update the replicas and additionally use the replicas as a distributed lock
to ensure that the database is updated in the correct order.
All in all, this costs four round-trips to the distant replicas;
expensive, but not prohibitive.
(Spokes has plans to reduce the number of round trips through the use of a more advanced consensus algorithm.)

As much as possible, Spokes also makes use of the time spent waiting on the network to get other work done.
For example, while one replica is acquiring its lock,
another replica might be computing a checksum and the coordinator might be reading from the database.

\emph{\href{https://gitlab.com/groups/gitlab-org/-/epics/1189}{Gitaly HA}} - not yet ready.

Gitaly Cluster allows Git repositories to be replicated on multiple warm Gitaly nodes.
This improves fault tolerance by removing single points of failure.
Reference transactions, introduced in GitLab 13.3,
causes changes to be broadcast to all the Gitaly nodes in the cluster,
but only the Gitaly nodes that vote in agreement with the primary node persist the changes to disk.
If all the replica nodes dissented, only one copy of the change would be persisted to disk,
creating a single point of failure until asynchronous replication completed.

Quorum-based voting improves fault tolerance by requiring a majority of nodes to agree before persisting changes to disk.
When the feature flag is enabled, writes must succeed on multiple nodes.
Dissenting nodes are automatically brought in sync by asynchronous replication from the nodes that formed the quorum.

It's currently in alpha and not enabled by default.
If enabled, transactions are only available for a subset of Gitaly RPCs.

\emph{\href{https://dsf.berkeley.edu/cs286/papers/paxoscommit-tods2006.pdf}{Paxos-commit}}

\section{Solution}

How to Lock:

We don't want to block all writes while someone is pushing a payload,
but we want to start the transaction right before a user attempts to write new refs.
With this approach only reference update will be synchronised and objects are uploaded asynchronously.

So we need to lock on all git reference update operations.
Git \emph{\href{https://git-scm.com/docs/githooks.html\#_reference_transaction}{reference-transaction hook}}
handles all reference update operations and queues reference updates to the transaction and locks reference updates on disk.
In the "prepared" state, a non-zero exit status will cause the transaction to be aborted.
And zero status - to be committed.
After that lock will be released.

So everything seems to be ready from the box.
We need only implement voting here and return zero status if all replicas/quorum have been agreed, and non-zero if quorum isn't reached.
As soon as it gets called, it will take all
of stdin and use it to cast a vote to a central service.
The most important upside is that this will catch all commands writing
references at once, allowing to implement strong consistency for
reference updates via a single mechanism.
Each of the hooks will block until it receives a message from coordinator telling to to either go on with the update or to abort.

So the solution is: implement atomic commit protocol in git reference transaction hook.

\section{Future work}

\begin{enumerate}
  \item compare atomic commit protocols: 2PC, 3PC, Paxos-commit
  \item implement and do benchmarking
  \item investigate self-healing mechanism
\end{enumerate}

\section{Conclusion}

Now DeGitX team has vision how to achieve strong consistency.

To simplify we decided to use 2PC as 3PC is about better failure recovery.
Also to perform commit at first we need an agreement from all nodes.

pros:
\begin{itemize}
  \item simple
  \item strong consistent
\end{itemize}

cons:
\begin{itemize}
  \item if a single replica fails, repository becomes read-only
\end{itemize}

\end{document}
